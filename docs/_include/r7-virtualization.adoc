:sectnums:
:sectnumlevels: 3
:imagesdir: ./_images

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

:toc:
:toclevels: 1

= Virtualization Management with Cockpit

You have already been introduced to the Webconsole system administration tool (Cockpit).  With the addition of a few more modules, the utility provides a robust interface for managing (kvm) virtualization.

== Getting Started

Log into workstation VM as student and then use sudo to gain root priviledges.

----
sudo -i
----

=== Requirements

First we need to ensure the system being used supports either:

    * Intel VT-x and Intel 64 virtualization extensions
    * AMD-V and the AMD64 virtualization extensions

This is done the following simple command.

----
grep -E 'svm|vmx' /proc/cpuinfo
----

You are looking for either the Intel flag (vtx) or the AMD flag (svm).  A more sophisticated command makes it a little easier to determine.

----
if grep -qE 'svm|vmx' /proc/cpuinfo ; then echo "Virt Supported" ; else echo "*WARN* Virt NOT Supported"; fi
----

=== Installation

Verifying that yum repos are enabled to install Cockpit and the virtualization tools.

----
# yum repolist
----

Make sure rhel-7-server-rpms, rhel-7-server-optional-rpms and rhel-7-server-extras-rpms repos are enabled.

Installing Packages for virtualization enablement

----
# yum install -y qemu-kvm libvirt virt-install libvirt-client libguestfs-tools
----

Installing Packages for webconsole enablement

----
# yum install -y cockpit cockpit-dashboard cockpit-machines 
----

To make the creating of custom VM images easy, install the Image-Builder tools

----
yum install -y lorax-composer composer-cli cockpit-composer
----


Enable System Services

----
# systemctl enable cockpit.socket lorax-composer.socket libvirtd
# systemctl start cockpit lorax-composer libvirtd
----

NOTE: As shown below, notice that the webconsole has been configured to run on port 443 in addition to  the standard port 9090.

You should see cockpit.service is now active and running.

----
# systemctl status cockpit.socket
----

----
* cockpit.service - Cockpit Web Service
   Loaded: loaded (/usr/lib/systemd/system/cockpit.service; static; vendor preset: disabled)
   Active: active (running) since Thu 2019-10-24 08:39:32 EDT; 15s ago
     Docs: man:cockpit-ws(8)
  Process: 14933 ExecStartPre=/usr/sbin/remotectl certificate --ensure --user=root --group=cockpit-ws --selinux-type=etc_t (code=exited, status=0/SUCCESS)
 Main PID: 14938 (cockpit-ws)
   CGroup: /system.slice/cockpit.service
           └─14938 /usr/libexec/cockpit-ws

* cockpit.socket - Cockpit Web Service Socket
   Loaded: loaded (/usr/lib/systemd/system/cockpit.socket; enabled; vendor preset: disabled)
  Drop-In: /etc/systemd/system/cockpit.socket.d
           └─listen.conf
   Active: active (running) since Thu 2019-10-24 08:01:23 EDT; 38min ago
     Docs: man:cockpit-ws(8)
   Listen: [::]:9090 (Stream)
           [::]:443 (Stream)
----

Firewall Configuration

If firewalld is active, configure firewalld to allow cockpit.

----
# firewall-cmd status
# firewall-cmd --add-port=9090/tcp
# firewall-cmd --permanent --add-port=9090/tcp
# firewall-cmd --list-ports
----

Verify Virtualization Host Status

----
virt-host-validate
----

----
QEMU: Checking for hardware virtualization                                 : PASS
QEMU: Checking if device /dev/kvm exists                                   : PASS
QEMU: Checking if device /dev/kvm is accessible                            : PASS
QEMU: Checking if device /dev/vhost-net exists                             : PASS
QEMU: Checking if device /dev/net/tun exists                               : PASS
QEMU: Checking for cgroup 'memory' controller support                      : PASS                                                    
QEMU: Checking for cgroup 'memory' controller mount-point                  : PASS
QEMU: Checking for cgroup 'cpu' controller support                         : PASS
QEMU: Checking for cgroup 'cpu' controller mount-point                     : PASS
QEMU: Checking for cgroup 'cpuacct' controller support                     : PASS
QEMU: Checking for cgroup 'cpuacct' controller mount-point                 : PASS
QEMU: Checking for cgroup 'cpuset' controller support                      : PASS
QEMU: Checking for cgroup 'cpuset' controller mount-point                  : PASS
QEMU: Checking for cgroup 'devices' controller support                     : PASS
QEMU: Checking for cgroup 'devices' controller mount-point                 : PASS
QEMU: Checking for cgroup 'blkio' controller support                       : PASS
QEMU: Checking for cgroup 'blkio' controller mount-point                   : PASS
QEMU: Checking for device assignment IOMMU support                         : WARN (No ACPI IVRS table found, IOMMU either disabled in BIOS or not supported by this hardware platform)
 LXC: Checking for Linux >= 2.6.26                                         : PASS
 LXC: Checking for namespace ipc                                           : PASS
 LXC: Checking for namespace mnt                                           : PASS
 LXC: Checking for namespace pid                                           : PASS
 LXC: Checking for namespace uts                                           : PASS
 LXC: Checking for namespace net                                           : PASS
 LXC: Checking for namespace user                                          : PASS
 LXC: Checking for cgroup 'memory' controller support                      : PASS
 LXC: Checking for cgroup 'memory' controller mount-point                  : PASS
 LXC: Checking for cgroup 'cpu' controller support                         : PASS
 LXC: Checking for cgroup 'cpu' controller mount-point                     : PASS
 LXC: Checking for cgroup 'cpuacct' controller support                     : PASS
 LXC: Checking for cgroup 'cpuacct' controller mount-point                 : PASS
 LXC: Checking for cgroup 'cpuset' controller support                      : PASS
 LXC: Checking for cgroup 'cpuset' controller mount-point                  : PASS
 LXC: Checking for cgroup 'devices' controller support                     : PASS
 LXC: Checking for cgroup 'devices' controller mount-point                 : PASS
 LXC: Checking for cgroup 'blkio' controller support                       : PASS
 LXC: Checking for cgroup 'blkio' controller mount-point                   : PASS
 LXC: Checking if device /sys/fs/fuse/connections exists                   : FAIL (Load the 'fuse' module to enable /proc/ overrides)
----

=== Configure Network Bridge


NOTE: I should be able to swizzle this into a nmcli command, but in the meantime using nmtui.

Kinda cool to show all properties:

----
nmcli con edit <name>
nmcli> ?
nmcli> print
nmcli> quit
----

----



NOTE: Becareful to ensure netowrk connection information is accurate.  IE: don't configure for DHCP if it should be using static IPs

export BRNAME=virbr1 DEVNAME=enp0s31f6

nmcli con add type bridge con-name ${BRNAME} ifname ${BRNAME} autoconnect yes bridge.stp no ipv6.method ignore
nmcli con modify ${BRNAME} connection.autoconnect-slaves yes

----

This is what I want ifcfg-<BRIDGE> to look like:

----
STP=no
TYPE=Bridge
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=no
NAME=virbr1
UUID=3aad9e94-507f-4c54-9579-c7d42e01fbf9
DEVICE=virbr1
ONBOOT=yes
AUTOCONNECT_SLAVES=yes
----

----
rm -f /etc/sysconfig/network-scripts/ifcfg-${DEVNAME}
nmcli con add type ethernet con-name ${DEVNAME} ifname ${DEVNAME} master ${BRNAME}
----

This is what I want in the ifcfg-<DEVICE> file

----
TYPE=Ethernet
NAME=enp0s31f6
UUID=2cdaf676-4f3f-44b3-b038-919eb5965432
DEVICE=enp0s31f6
ONBOOT=yes
BRIDGE=virbr1
----

----
ifdown ${DEVNAME} ; sleep 3 ; ifdown ${BRNAME} ; sleep 3; ifup ${BRNAME}
----

=== Configure Libvirt to use Bridge

----
cat > /var/tmp/bridge.xml <<EOF
<network>
    <name>host-bridge</name>
    <forward mode="bridge"/>
    <bridge name="${BRNAME}"/>
</network>
EOF

virsh net-define /var/tmp/bridge.xml

virsh net-list --all

virsh net-start host-bridge

virsh net-autostart host-bridge
----

See reference doc: http://blog.leifmadsen.com/blog/2016/12/01/create-network-bridge-with-nmcli-for-libvirt/

=== Install VM from ISO

==== Fetch ISO from redhat.com


Log on to access.redhat.com

Go to Downloads

Select Red Hat Enterprise Linux (rhel 7 or older releases if needed)

copy the URL [right click] for the "Red Hat Enterprise Linux KVM Guest Image"

On our host, change directories to /var/lib/libvirt/images

Be sure to use quotes around the link

wget "<paste link>"

==== Configure HTTP Accessible ks.cfg

Install httpd
Service Enable http
Firewall add http
Create ks.cfg

==== Use Web Console to Install A System


==== virt-install to Install A System from ISO

virt-install --name=ocp-bastion --ram=16000 --location=/var/lib/libvirt/images/rhel-8.1-x86_64-dvd.iso --extra-args="ks=http://rhv2.lab.linuxsoup.com/ks.cfg" --disk /var/lib/libvirt/images/ocp-bastion.qcow2,bus=scsi,sparse=no,size=25 --graphics vnc

==== virt-install to Install A System from Discovery ISO

virt-install --name=vm01 --file=/var/lib/libvirt/images/vm01.qcow2 --file-size=20 --nonsparse --ram=6000 --cdrom=/var/lib/libvirt/images/foreman-discovery-ExampleCom.iso  --graphics vnc

== Additional Resources


https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/networking_guide/ch-configure_network_bridging

http://blog.leifmadsen.com/blog/2016/12/01/create-network-bridge-with-nmcli-for-libvirt/

Cockpit Project Page

    * link:http://cockpit-project.org/blog/category/release.html[Cockpit Project]

[discrete]
== End of Unit

link:../RHEL7-Workshop.adoc#toc[Return to TOC]



////
Always end files with a blank line to avoid include problems.
////
