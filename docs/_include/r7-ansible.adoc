
:sectnums:
:sectnumlevels: 3
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

= System Automation with Ansible and System-Roles

Ansible is an open source automation platform that uses a simple automation language
that describes an IT application infrastructure within Ansible Playbooks. Ansible is also
an automation engine that runs Ansible Playbooks.
You can utilize Ansible in many ways:

  * Device configuration management
  * Application deployment
  * Provisioning
  * Continuous delivery
  * Security and compliance
  *Orchestration

`ansible` is the primary command line tool to initiate a ad hoc command.
`ansible-playbook` is the command line tool to run Ansible Playbooks. The syntax used for configuring Ansible Playbooks is written in YAML.

The Ansible Engine product channel is provided as a convenience with the Red Hat Enterprise Linux subscription as a unsupported dependency for the implementation of RHEL System Roles. However, support of Ansible Engine product by the RHEL subscription is limited to the context of, and modules used by, RHEL System Roles. A full support subscription is available for Ansible Engine and Ansible Tower which are also able to use the RHEL System Roles.

== Ansible Concepts


There are two types of machines in the Ansible architecture: control nodes and managed hosts . Ansible is installed and run from a control node(s), which also has copies of Ansible configuration files. Managed hosts are listed in an inventory file, which can also organize those systems into groups for easier management. The inventory can be defined in a static text file (INI), or via a dynamic file determined by scripts that get information from external files.

Ansible users create high-level plays to ensure a host or group of hosts are in a particular state. A play performs several tasks , in order, on a host or set of hosts. A file that contains one or more plays is called a playbook. Each task runs a module , a small piece of code that is written in Python, Powershell, or some other language with specific arguments. Each module is a tool in your toolkit. By default, Ansible ships with hundreds of these modules that perform a wide variety of tasks. For example, modules can install software, make API calls, or act on system files.

== RHEL System-Roles Concepts

Red Hat Enterprise Linux (RHEL) 7.4 introduced RHEL System Roles as a Technology Preview. The RHEL System Roles are a collection of Ansible roles and modules that provide a stable and consistent configuration interface to remotely manage RHEL 6.9 and later versions of Red Hat Enterprise Linux (including RHEL 7.5 as a Technology Preview). This effort is based on development of the Linux System Roles upstream project.

RHEL System Roles will provide the user a consistent user interface to provide settings to a given subsystem that is abstract from any one particular implementation or configuration. Thereby, making generic system configurations easy to maintain with consistent automation techniques while maintaining modularity.

The initial set of roles includes:
  * kdump
  * postfix
  * network
  * selinux
  * timesync
  
The RHEL System Roles are provided in the RHEL Extras channel which provides customers access to select, and quickly evolving system roles. Typically Ansible Engine and the RHEL System Roles only need to be installed on a single, or few, control node(s) which can then be used to manage or configure client nodes. While the roles will likely work with earlier versions, compatibility is only tested against RHEL 6.9 and later clients.

== Getting Started

The `rhel-system-roles` and `ansible` RPM packages are provided in the RHEL Extras channel. The Extras channel should be enabled by default in your workshop environment. To install Ansible and RHEL System Roles, log into the workstation as root and run the following commands:

.[root@workstation]#
----
yum install -y rhel-system-roles ansible
----

.Command Output
[source,indent=4]
----
..<SNIP>..
Package ansible-2.4.2.0-2.el7.noarch already installed and latest
version
Resolving Dependencies
--> Running transaction check
---> Package rhel-system-roles.noarch 0:0.6-3.el7 will be
installed
--> Finished Dependency Resolution
Installed:
rhel-system-roles.noarch 0:0.6-3.el7
..<SNIP>..
----

RHEL System Roles documentation is located in: `/usr/share/doc/rhel-system-roles/SUBSYSTEM/`

Ansible Roles documentation is located in: `/usr/share/ansible/roles/rhel-system-roles.SUBSYSTEM/`

== AdHoc Commands

Now that we have installed Ansible and RHEL System Roles and a general understanding of what Ansible is, let’s create and modify the initial configuration file to run a few modules against our managed hosts using our _inventory_ file.

=== Create Ansible Configuration

Run the following to create you ansible configuration file.

.[root@workstation]#
----
cheat-ansible-config.sh
----

=== Create Ansible Inventory

Run the following command to create your _inventory_ file.

.[root@workstation]#
----
cheat-ansible-inventory.sh
----

=== Ansible AdHoc: ping

.[root@workstation]#
----
ansible servers -m ping
----

.Command Output
[source,indent=4]
----
server2.example.com | SUCCESS => {
"changed": false,
"ping": "pong"
}
server1.example.com | SUCCESS => {
"changed": false,
"ping": "pong"
}
----

=== Ansible AdHoc: setup

.[root@workstation]#
----
ansible -m setup -a ‘filter=ansible_eth0’ server1.example.com
----

.Command Output
[source,indent=4]
----
..<SNIP>..
server1.example.com | SUCCESS => {
  "ansible_facts": {
    "ansible_eth0": {
      "active": true,
      "device": "eth0",
      "features": {
        "busy_poll": "off [fixed]",
        "fcoe_mtu": "off [fixed]",
..<SNIP>..
"ipv4": {
  "address": "10.0.0.11",
  "broadcast": "10.0.0.255",
  "netmask": "255.255.255.0",
  "network": "10.0.0.0"
  },
"ipv6": [
  {
    "address": "fe80::2ec2:60ff:fe02:d1d5",
    "prefix": "64",
    "scope": "link"
  }
----

== Ansible Playbook wth Roles

Let’s now define the role content for use with Ansible Playbooks that introduces RHEL System Roles. In this case we’ll create a role called “motd”.

First, create the directory structure for the “motd” role:

.[root@workstation]#
----
cd /root
mkdir roles
cd roles
ansible-galaxy init motd
----

Second, create a jinja template file.

.[root@workstation]#
----
cheat-ansible-motd-template.sh
----

Now modify the main.yml to define a variable

.[root@workstation]#
----
cheat-ansible-motd-main.sh
----

And finally, adjust the playbook to call our new `motd` role.

.[root@workstation]#
----
cheat-ansible-playbook.sh
----

Now run the playbook with our cutom `motd` role.

.[root@workstation]#
----
ansible-playbook use-motd-role.yml
----

.Command Output
[source,indent=4]
----
PLAY [Use MOTD role playbook]
*****************************************************************
TASK [Gathering Facts]
*****************************************************************
ok: [server1.example.com]
TASK [motd : Deliver MOTD file]
*****************************************************************
changed: [server1.example.com]
PLAY RECAP
*****************************************************************
server1.example.com : ok=2 changed=1 unreachable=0
failed=0
----

When the playbook was executed the tasks continued to perform because the role itself
can be identified by the roles configuration within the playbook.

=== Validation

As the user `root`, ssh to `server1.example.com` and verify that the _message of the day_ and been modified to our new standard.

.[root@workstation]#
----
ssh root@server1.example.com
----

.Command Output
[source,indent=4]
----
This is the system server1.example.com.
Today's date is: 2018-05-04.
Only use this system with permission.
You can ask root@workstation.example.com for access.
----

== Additional Resources

Red Hat Documentation

    * link:https://https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8-beta/html/installing_identity_management_and_access_control/deploying-session-recording[Deplying Session Recording on Red Hat Enterprise Linux]

[discrete]
== End of Unit

link:../RHEL7-Workshop.adoc#toc[Return to TOC]

////
Always end files with a blank line to avoid include problems.
////
